<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bdsim.components &mdash; Block diagram simulation  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Block diagram simulation
              <img src="../../_static/BDSimLogo_NoBackgnd@2x.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Code documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bdsim.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bdsim.blocks.html">Block library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../internals.html">Supporting classes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Block diagram simulation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bdsim.components</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bdsim.components</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Components of the simulation system, namely blocks, wires and plugs.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">animation</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">UserDict</span>

<span class="c1"># decorator for debugging implicit block creation with operator overloading</span>
<span class="k">def</span> <span class="nf">oodebug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># print(f&quot;{func.__qualname__}{args} --&gt; {ret}&quot;)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">BDStruct</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple data container object that allows items to be added by attribute or by</span>
<span class="sd">    index.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; d = BDStruct(&#39;thing&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d.foo = 1</span>
<span class="sd">        &gt;&gt;&gt; d.foo</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; d[&quot;foo&quot;]</span>
<span class="sd">        ]</span>
<span class="sd">        &gt;&gt;&gt; d[&quot;bar&quot;] = 2</span>
<span class="sd">        &gt;&gt;&gt; d.bar</span>
<span class="sd">        &gt;&gt;&gt; d</span>
<span class="sd">        bar   = 2 (int)</span>
<span class="sd">        foo   = 1 (int)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;BDStruct2&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># self.__dict__[key] = value</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># self.__dict__[name] = value</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)])</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display struct as a string</span>

<span class="sd">        :return: struct in indented string format</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        The struct is rendered with one line per element, and substructures</span>
<span class="sd">        are indented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="n">maxwidth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="c1"># if self.name is not None:</span>
        <span class="c1">#     rows.append(self.name + &#39;::&#39;)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">BDStruct</span><span class="p">):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2">.</span><span class="si">{:s}</span><span class="s2">::&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">maxwidth</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">[</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxwidth</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="si">{:s}</span><span class="s1"> = &quot;</span><span class="si">{:s}</span><span class="s1">&quot; (</span><span class="si">{:s}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">maxwidth</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> = ndarray:</span><span class="si">{:s}</span><span class="s2"> </span><span class="si">{:s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">maxwidth</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> = </span><span class="si">{:s}</span><span class="s2"> (</span><span class="si">{:s}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">maxwidth</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pickle</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OptionsBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A struct like object for option handling</span>

<span class="sd">    Maintains an internal dict to keep options and their values.  Some of these</span>
<span class="sd">    values, names in the ``_priority`` list are read-only and cannot be changed.</span>

<span class="sd">    Values can be read/written as attributes, or the ``set`` method can take</span>
<span class="sd">    a sequence of ``option=value`` arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="p">{},</span> <span class="n">args</span><span class="o">=</span><span class="p">{}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readonly</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">readonly</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">readonly</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_dict&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_dict&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readonly</span><span class="p">:</span>
                <span class="nb">dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sanity</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">changes</span><span class="p">):</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sanity</span><span class="p">(</span><span class="n">changes</span><span class="p">)</span>
        <span class="nb">dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">changes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readonly</span><span class="p">:</span>
                <span class="nb">dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="nb">dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;attempt to programmatically set option </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> is&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; overriden by command line option </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="nb">dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">, ignored&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span> <span class="o">=</span> <span class="nb">dict</span>

    <span class="k">def</span> <span class="nf">sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">options</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict</span>
        <span class="n">maxwidth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="n">options</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">option</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">maxwidth</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">dict</span><span class="p">[</span><span class="n">option</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="Wire">
<a class="viewcode-back" href="../../internals.html#bdsim.Wire">[docs]</a>
<span class="k">class</span> <span class="nc">Wire</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a wire.</span>

<span class="sd">    :param start: Plug at the start of a wire, defaults to None</span>
<span class="sd">    :type start: Plug, optional</span>
<span class="sd">    :param end: Plug at the end of a wire, defaults to None</span>
<span class="sd">    :type end: Plug, optional</span>
<span class="sd">    :param name: Name of wire, defaults to None</span>
<span class="sd">    :type name: str, optional</span>
<span class="sd">    :return: A wire object</span>
<span class="sd">    :rtype: Wire</span>

<span class="sd">    A Wire object connects two block ports.  A Wire has a reference to the</span>
<span class="sd">    start and end ports.</span>

<span class="sd">    A wire records all the connections defined by the user.  At compile time</span>
<span class="sd">    wires are used to build inter-block references.</span>

<span class="sd">    Between two blocks, a wire can connect one or more ports, ie. it can connect</span>
<span class="sd">    a set of output ports on one block to a same sized set of input ports on</span>
<span class="sd">    another block.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interactive display of wire properties.</span>

<span class="sd">        Displays all attributes of the wire for debugging purposes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;wire:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">{:8s}{:s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display wire with name and connection details.</span>

<span class="sd">        :return: Long-form wire description</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        String format::</span>

<span class="sd">            wire.5: d2goal[0] --&gt; Kv[0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fullname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display wire connection details.</span>

<span class="sd">        :return: Wire name</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        String format::</span>

<span class="sd">            d2goal[0] --&gt; Kv[0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2">[</span><span class="si">{:d}</span><span class="s2">] --&gt; </span><span class="si">{:s}</span><span class="s2">[</span><span class="si">{:d}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">block</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">block</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">port</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display wire name.</span>

<span class="sd">        :return: Wire name</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        String format::</span>

<span class="sd">            wire.5</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;wire.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;??&quot;</span>
        <span class="k">return</span> <span class="n">s</span></div>



<span class="c1"># ------------------------------------------------------------------------- #</span>


<div class="viewcode-block" id="Plug">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug">[docs]</a>
<span class="k">class</span> <span class="nc">Plug</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a plug.</span>

<span class="sd">    :param block: The block being plugged into</span>
<span class="sd">    :type block: Block</span>
<span class="sd">    :param port: The port on the block, defaults to 0</span>
<span class="sd">    :type port: int, optional</span>
<span class="sd">    :param type: &#39;start&#39; or &#39;end&#39;, defaults to None</span>
<span class="sd">    :type type: str, optional</span>
<span class="sd">    :return: Plug object</span>
<span class="sd">    :rtype: Plug</span>

<span class="sd">    Plugs are the interface between a wire and block and have information</span>
<span class="sd">    about port number and wire end. Plugs are on the end of each wire, and connect a</span>
<span class="sd">    Wire to a specific port on a Block.</span>

<span class="sd">    The ``type`` argument indicates if the ``Plug`` is at:</span>
<span class="sd">        - the start of a wire, ie. the port is an output port</span>
<span class="sd">        - the end of a wire, ie. the port is an input port</span>

<span class="sd">    A plug can specify a set of ports on a block.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__array_ufunc__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># allow block operators with NumPy values</span>

<div class="viewcode-block" id="Plug.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>  <span class="c1"># start</span></div>


<div class="viewcode-block" id="Plug.__str__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display plug details.</span>

<span class="sd">        :return: Plug description</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        String format::</span>

<span class="sd">            bicycle.0[1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span></div>


<div class="viewcode-block" id="Plug.__repr__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__repr__">[docs]</a>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display plug details.</span>

<span class="sd">        :return: Plug description</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        String format::</span>

<span class="sd">            bicycle.0[1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Plug/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isslice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if port number is a slice.</span>

<span class="sd">        :return: Whether the port is a slice</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        Returns ``True`` if the port is a slice, eg. ``[0:3]``, and ``False``</span>
<span class="sd">        for a simple index, eg. ``[2]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">portlist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return port numbers.</span>

<span class="sd">        :return: Port numbers</span>
<span class="sd">        :rtype: iterable of int</span>

<span class="sd">        If the port is a simple index, eg. ``[2]`` returns [2].</span>

<span class="sd">        If the port is a slice, eg. ``[0:3]``, returns [0, 1, 2].</span>
<span class="sd">        For the case ``[2:]`` the upper bound is the maximum number of input</span>
<span class="sd">        or output ports of the block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># easy case, this plug is a single wire</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># this plug is a bunch of wires</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span>
            <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">nout</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">nin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="o">.</span><span class="n">stop</span>

            <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad plug index&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Plug.__getitem__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">portlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of ports connected.</span>

<span class="sd">        :return: Number of ports</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        If the port is a simple index, eg. ``[2]`` returns 1.</span>

<span class="sd">        If the port is a slice, eg. ``[0:3]``, returns 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">portlist</span><span class="p">)</span>

<div class="viewcode-block" id="Plug.__rshift__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__rshift__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded &gt;&gt; operator for implicit wiring.</span>

<span class="sd">        :param left: A plug to be wired from</span>
<span class="sd">        :type left: Plug</span>
<span class="sd">        :param right: A block or plug to be wired to</span>
<span class="sd">        :type right: Block or Plug</span>
<span class="sd">        :return: ``right``</span>
<span class="sd">        :rtype: Block or Plug</span>

<span class="sd">        Implements implicit wiring, where the left-hand operator is a Plug, for example::</span>

<span class="sd">            a = bike[2] &gt;&gt; bd.GAIN(3)</span>

<span class="sd">        will connect port 2 of ``bike`` to the input of the GAIN block.</span>

<span class="sd">        Note that::</span>

<span class="sd">           a = bike[2] &gt;&gt; func[1]</span>

<span class="sd">        will connect port 2 of ``bike`` to port 1 of ``func``, and port 1 of ``func``</span>
<span class="sd">        will be assigned to ``a``.  To specify a different outport port on ``func``</span>
<span class="sd">        we need to use parentheses::</span>

<span class="sd">            a = (bike[2] &gt;&gt; func[1])[0]</span>

<span class="sd">        which will connect port 2 of ``bike`` to port 1 of ``func``, and port 0 of ``func``</span>
<span class="sd">        will be assigned to ``a``.</span>

<span class="sd">        :seealso: Block.__mul__</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># called for the cases:</span>
        <span class="c1"># block * block</span>
        <span class="c1"># block * plug</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span>
        <span class="c1"># assert isinstance(right, Block), &#39;arguments to * must be blocks not ports (for now)&#39;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>  <span class="c1"># add a wire</span>
        <span class="c1"># print(&#39;plug * &#39; + str(w))</span>
        <span class="k">return</span> <span class="n">right</span></div>


<div class="viewcode-block" id="Plug.__add__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__add__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded + operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be added</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be added</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the + operator when the left operand is a ``Plug``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X[i] + Y</span>
<span class="sd">            result = X[i] + Y[j]</span>
<span class="sd">            result = X[i] + C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``SUM(&quot;++&quot;)`` block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        :seealso: :meth:`Plug.__radd__` :meth:`Block.__add__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># plug + constant, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;++&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span></div>


<div class="viewcode-block" id="Plug.__radd__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__radd__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded + operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be added</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be added</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the + operator when the right operand is a ``Plug``</span>
<span class="sd">        and the left operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X + Y[j]</span>
<span class="sd">            result = X[i] + Y[j]</span>
<span class="sd">            result = C + Y[j]</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``SUM(&quot;++&quot;) block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note:: The inputs to the summing junction are reversed: right then left operand.</span>

<span class="sd">        :seealso: :meth:`Plug.__add__` :meth:`Block.__radd__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant + plug, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;++&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="Plug.__sub__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__sub__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded - operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be added (minuend)</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be subtracted (subtrahend)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the - operator when the left operand is a ``Plug``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X[i] - Y</span>
<span class="sd">            result = X[i] - Y[j]</span>
<span class="sd">            result = X[i] - C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``SUM(&quot;+-&quot;)`` block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note::</span>
<span class="sd">                * The ``mode`` is None, regular addition</span>

<span class="sd">        :seealso: :meth:`Plug.__rsub__` :meth:`Block.__sub__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># plug - constant, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span></div>


<div class="viewcode-block" id="Plug.__rsub__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__rsub__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded - operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be added (minuend)</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be subtracted (subtrahend)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the - operator when the left operand is a ``Plug``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X - Y[j]</span>
<span class="sd">            result = X[i] - Y[j]</span>
<span class="sd">            result = C - Y[j]</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``SUM(&quot;+-&quot;)`` block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note:: The inputs to the summing junction are reversed: right then left operand.</span>

<span class="sd">        :seealso: :meth:`Plug.__sub__` :meth:`Block.__rsub__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO deal with other cases as per above</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant - plug, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="Plug.__neg__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__neg__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded unary minus operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be negated</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :return: GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the - operator for unary minus when the operand is a ``Plug``::</span>

<span class="sd">            result = -X[i]</span>

<span class="sd">        where ``X`` is a block.</span>

<span class="sd">        Create a ``GAIN(-1)`` block named ``_gain.N`` whose input is the</span>
<span class="sd">        operand.</span>

<span class="sd">        :seealso: :meth:`Block.__neg__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">GAIN</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span></div>


<div class="viewcode-block" id="Plug.__pow__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__pow__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded unary power operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be exponentiated</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :return: POW block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the ** operator for unary power when the operand is a ``Block``::</span>

<span class="sd">            result = X**3</span>

<span class="sd">        where ``X`` is a block.</span>

<span class="sd">        Creates a ``POW(3)`` block named ``_pow.N`` whose input is the</span>
<span class="sd">        operand.</span>

<span class="sd">        :seealso: :meth:`Plug.__pow__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">POW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span></div>


<div class="viewcode-block" id="Plug.__mul__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__mul__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded * operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be multiplied</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be multiplied</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD or GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the * operator when the left operand is a ``Plug``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X[i] * Y</span>
<span class="sd">            result = X[i] * Y[j]</span>
<span class="sd">            result = X[i] * C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``PROD(&quot;**&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.</span>

<span class="sd">        For the third case, create a ``GAIN(C)`` block named ``_gain.N``.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Plug.__rmul__` :meth:`Block.__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># plug * constant, create a GAIN block</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">_autogain</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># value * value, create a PROD block</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_prod.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">PROD</span><span class="p">(</span>
                <span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Plug.__rmul__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__rmul__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded * operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be multiplied</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be multiplied</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD or GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the * operator when the right operand is a ``Plug``</span>
<span class="sd">        and the left operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X * Y[j]</span>
<span class="sd">            result = X[i] * Y[j]</span>
<span class="sd">            result = C * Y[j]</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        For the first two cases, a ``PROD(&quot;**&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.</span>

<span class="sd">        For the third case, create a ``GAIN(C)`` block named ``_gain.N``.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Plug.__mul__` :meth:`Block.__rmul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant * plug, create a CONSTANT block</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">_autogain</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">premul</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span></div>


<div class="viewcode-block" id="Plug.__truediv__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__truediv__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded / operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be multiplied (dividend)</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be divided (divisor)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD or GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the / operator when the left operand is a ``Plug``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X[i] / Y</span>
<span class="sd">            result = X[i] / Y[j]</span>
<span class="sd">            result = X[i] / C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``PROD(&quot;**&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.</span>

<span class="sd">        For the third case, create a ``GAIN(1/C)`` block named ``_gain.N``.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Plug.__rtruediv__` :meth:`Block.__truediv__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># plug / constant , create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">PROD</span><span class="p">(</span><span class="s2">&quot;*/&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span></div>


<div class="viewcode-block" id="Plug.__rtruediv__">
<a class="viewcode-back" href="../../internals.html#bdsim.Plug.__rtruediv__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded / operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (plug) to be multiplied (dividend)</span>
<span class="sd">        :type self: Plug</span>
<span class="sd">        :param other: A signal (block or plug) to be divided (divisor)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the / operator when the right operand is a ``Plug``</span>
<span class="sd">        and the left operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X / Y[j]</span>
<span class="sd">            result = X[i] / Y[j]</span>
<span class="sd">            result = C / Y[j]</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        For the first two cases, a ``PROD(&quot;*/&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new CONSTANT block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Plug.__truediv__` :meth:`Block.__rtruediv__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant / plug, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">PROD</span><span class="p">(</span><span class="s2">&quot;*/&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span></div>
</div>



<span class="k">class</span> <span class="nc">StartPlug</span><span class="p">(</span><span class="n">Plug</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">EndPlug</span><span class="p">(</span><span class="n">Plug</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># ------------------------------------------------------------------------- #</span>

<span class="n">clocklist</span> <span class="o">=</span> <span class="p">[]</span>


<div class="viewcode-block" id="Clock">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock">[docs]</a>
<span class="k">class</span> <span class="nc">Clock</span><span class="p">:</span>
<div class="viewcode-block" id="Clock.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">clocklist</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;ms&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;Hz&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">arg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown clock unit&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># discrete state vector numpy.ndarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tick</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;clock.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clocklist</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="n">clocklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


        <span class="c1"># events happen at time t = kT + offset</span>

<div class="viewcode-block" id="Clock.add_block">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.add_block">[docs]</a>
    <span class="k">def</span> <span class="nf">add_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: T=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="si">}</span><span class="s2"> sec&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, offset=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, clocking </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="p">)</span><span class="si">}</span><span class="s2"> blocks&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="Clock.getstate0">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.getstate0">[docs]</a>
    <span class="k">def</span> <span class="nf">getstate0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># get the state from each stateful block on this clock</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">getstate0</span><span class="p">()]</span>
            <span class="c1"># print(&#39;x0&#39;, x0)</span>
        <span class="k">return</span> <span class="n">x0</span></div>


<div class="viewcode-block" id="Clock.getstate">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.getstate">[docs]</a>
    <span class="k">def</span> <span class="nf">getstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="p">:</span>
            <span class="c1"># update dstate</span>
            <span class="n">xb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>

        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="Clock.setstate">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.setstate">[docs]</a>
    <span class="k">def</span> <span class="nf">setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocklist</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">setstate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># send it to blocks</span></div>


<div class="viewcode-block" id="Clock.start">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.start">[docs]</a>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simstate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">simstate</span><span class="o">.</span><span class="n">declare_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Clock.next_event">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.next_event">[docs]</a>
    <span class="k">def</span> <span class="nf">next_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simstate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">simstate</span><span class="o">.</span><span class="n">declare_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Clock.time">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.time">[docs]</a>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="c1"># return (math.floor((t - self.offset) / self.T) + 1) * self.T + self.offset</span>
        <span class="c1"># k = int((t - self.offset) / self.T + 0.5)</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span></div>


<div class="viewcode-block" id="Clock.savestate">
<a class="viewcode-back" href="../../internals.html#bdsim.Clock.savestate">[docs]</a>
    <span class="k">def</span> <span class="nf">savestate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="c1"># save clock state at time t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getstate</span><span class="p">(</span><span class="n">t</span><span class="p">))</span></div>
</div>



<span class="c1"># ------------------------------------------------------------------------- #</span>


<div class="viewcode-block" id="Block">
<a class="viewcode-back" href="../../internals.html#bdsim.Block">[docs]</a>
<span class="k">class</span> <span class="nc">Block</span><span class="p">:</span>

    <span class="n">varinputs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">varoutputs</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">__array_ufunc__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># allow block operators with NumPy values</span>

<div class="viewcode-block" id="Block.__new__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__new__">[docs]</a>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">bd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new Block object.</span>

<span class="sd">        :param cls: The class to construct</span>
<span class="sd">        :type cls: class type</span>
<span class="sd">        :param *args: positional args passed to constructor</span>
<span class="sd">        :type *args: list</span>
<span class="sd">        :param **kwargs: keyword args passed to constructor</span>
<span class="sd">        :type **kwargs: dict</span>
<span class="sd">        :return: new Block instance</span>
<span class="sd">        :rtype: Block instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Block __new__&#39;, args,bd, kwargs)</span>
        <span class="n">block</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Block</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>  <span class="c1"># create a new instance</span>

        <span class="c1"># we overload setattr, so need to know whether it is being passed a port</span>
        <span class="c1"># name.  Add this attribute now to allow proper operation.</span>
        <span class="n">block</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;portnames&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># must be first, see __setattr__</span>

        <span class="n">block</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">block</span><span class="o">.</span><span class="n">ndstates</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">block</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">block</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># state vector</span>

        <span class="k">return</span> <span class="n">block</span></div>


    <span class="n">_latex_remove</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">maketrans</span><span class="p">({</span><span class="s2">&quot;$&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">})</span>

<div class="viewcode-block" id="Block.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">onames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">blockclass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new block object.</span>

<span class="sd">        :param name: Name of the block, defaults to None</span>
<span class="sd">        :type name: str, optional</span>
<span class="sd">        :param nin: Number of inputs, defaults to None</span>
<span class="sd">        :type nin: int, optional</span>
<span class="sd">        :param nout: Number of outputs, defaults to None</span>
<span class="sd">        :type nout: int, optional</span>
<span class="sd">        :param inputs: Optional incoming connections</span>
<span class="sd">        :type inputs: Block, Plug or list of Block or Plug</span>
<span class="sd">        :param inames: Names of input ports, defaults to None</span>
<span class="sd">        :type inames: list of str, optional</span>
<span class="sd">        :param onames: Names of output ports, defaults to None</span>
<span class="sd">        :type onames: list of str, optional</span>
<span class="sd">        :param snames: Names of states, defaults to None</span>
<span class="sd">        :type snames: list of str, optional</span>
<span class="sd">        :param pos: Position of block on the canvas, defaults to None</span>
<span class="sd">        :type pos: 2-element tuple or list, optional</span>
<span class="sd">        :param bd: Parent block diagram, defaults to None</span>
<span class="sd">        :type bd: BlockDiagram, optional</span>
<span class="sd">        :param verbose: enable diagnostic prints, defaults to False</span>
<span class="sd">        :type verbose: bool, optional</span>
<span class="sd">        :param kwargs: Unused arguments</span>
<span class="sd">        :type kwargs: dict</span>
<span class="sd">        :return: A Block superclass</span>
<span class="sd">        :rtype: Block</span>

<span class="sd">        A block object is the superclass of all blocks in the simulation environment.</span>

<span class="sd">        This is the top-level initializer, and handles most options passed to</span>
<span class="sd">        the superclass initializer for each block in the library.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># print(&#39;Block constructor, bd = &#39;, bd)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_tex</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixname</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_tex</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span> <span class="o">=</span> <span class="n">bd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="s2">&quot;block&quot;</span>  <span class="c1"># for box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inport_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outport_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initd</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clocked</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graphics</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">if</span> <span class="n">nin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="n">nin</span>
        <span class="k">if</span> <span class="n">nout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nout</span> <span class="o">=</span> <span class="n">nout</span>
        <span class="k">if</span> <span class="n">blockclass</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blockclass</span> <span class="o">=</span> <span class="n">blockclass</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bd</span><span class="o">.</span><span class="n">add_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inport_names</span><span class="p">(</span><span class="n">inames</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">onames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outport_names</span><span class="p">(</span><span class="n">onames</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">snames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_names</span><span class="p">(</span><span class="n">snames</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">Block</span><span class="p">):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># assert len(inputs) == self.nin, &#39;Number of input connections must match number of inputs&#39;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">Plug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: unused arguments&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="Block.add_param">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.add_param">[docs]</a>
    <span class="k">def</span> <span class="nf">add_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">handler</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newvalue</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newvalue</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_parameters&quot;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span></div>


<div class="viewcode-block" id="Block.set_param">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.set_param">[docs]</a>
    <span class="k">def</span> <span class="nf">set_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newvalue</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;setting parameter </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> of block </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">newvalue</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">name</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newvalue</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interactive display of block properties.</span>

<span class="sd">        Displays all attributes of the block for debugging purposes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;block: &quot;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;sim&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">{:11s}{:s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isclocked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if block is clocked</span>

<span class="sd">        :return: True if block is clocked</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        True if block is clocked, False if it is continuous time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clocked</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isgraphics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if block does graphics</span>

<span class="sd">        :return: True if block does graphics</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graphics</span>

    <span class="c1"># for use in unit testing</span>

    <span class="c1"># TODO: should redo this, eliminate the monkey patch</span>
    <span class="c1"># TODO: make T_step(), dummpy out the state object</span>

<div class="viewcode-block" id="Block.T_output">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.T_output">[docs]</a>
    <span class="k">def</span> <span class="nf">T_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a block for unit testing.</span>

<span class="sd">        :param *inputs: Input port values</span>
<span class="sd">        :param t: Simulation time, defaults to 0.0</span>
<span class="sd">        :type t: float, optional</span>
<span class="sd">        :param x: state vector</span>
<span class="sd">        :type x: ndarray</span>
<span class="sd">        :return: Block output port values</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        The output ports of the block are evaluated for a given simulation time</span>
<span class="sd">        and set of input port values. Input ports are assigned to consecutive inputs,</span>
<span class="sd">        output port values are a list.</span>

<span class="sd">        Mostly used for making concise unit tests.</span>

<span class="sd">        .. warning:: the instance is monkey patched, not useable in a block</span>
<span class="sd">            diagram subsequently.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check inputs and assign to attribute</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span><span class="p">,</span> <span class="s2">&quot;wrong number of inputs provided&quot;</span>

        <span class="c1"># evaluate the block</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="c1"># sanity check the output</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;result must be a list&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nout</span><span class="p">,</span> <span class="s2">&quot;result list is wrong length&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Block.T_deriv">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.T_deriv">[docs]</a>
    <span class="k">def</span> <span class="nf">T_deriv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a block for unit testing.</span>

<span class="sd">        :param inputs: input port values</span>
<span class="sd">        :type inputs: list</span>
<span class="sd">        :param t: Simulation time, defaults to 0.0</span>
<span class="sd">        :type t: float, optional</span>
<span class="sd">        :param x: state vector</span>
<span class="sd">        :type x: ndarray</span>
<span class="sd">        :return: Block derivative value</span>
<span class="sd">        :rtype: ndarray</span>

<span class="sd">        The derivative of the block is evaluated for a given set of input port</span>
<span class="sd">        values. Input port values are treated as lists.</span>

<span class="sd">        Mostly used for making concise unit tests.</span>

<span class="sd">        .. warning:: the instance is monkey patched, not useable in a block</span>
<span class="sd">            diagram subsequently.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check inputs and assign to attribute</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span><span class="p">,</span> <span class="s2">&quot;wrong number of inputs provided&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,</span> <span class="s2">&quot;passed state is wrong length&quot;</span>

        <span class="c1"># evaluate the block</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="c1"># sanity check the output</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;result must be an ndarray&quot;</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,),</span> <span class="s2">&quot;result array is wrong length&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Block.T_next">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.T_next">[docs]</a>
    <span class="k">def</span> <span class="nf">T_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a block for unit testing.</span>

<span class="sd">        :param inputs: input port values</span>
<span class="sd">        :type inputs: list</span>
<span class="sd">        :param t: Simulation time, defaults to 0.0</span>
<span class="sd">        :type t: float, optional</span>
<span class="sd">        :param x: state vector</span>
<span class="sd">        :type x: ndarray</span>
<span class="sd">        :return: Block next state value</span>
<span class="sd">        :rtype: ndarray</span>

<span class="sd">        The next value of a discrete time block is evaluated for a given set of input port</span>
<span class="sd">        values. Input port values are treated as lists.</span>

<span class="sd">        Mostly used for making concise unit tests.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check inputs and assign to attribute</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span><span class="p">,</span> <span class="s2">&quot;wrong number of inputs provided&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndstates</span><span class="p">,</span> <span class="s2">&quot;passed state is wrong length&quot;</span>

        <span class="c1"># evaluate the block</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="c1"># sanity check the output</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;next state must be an ndarray&quot;</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndstates</span><span class="p">,),</span> <span class="s2">&quot;next state array is wrong length&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Block.T_step">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.T_step">[docs]</a>
    <span class="k">def</span> <span class="nf">T_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step a block for unit testing.</span>

<span class="sd">        :param inputs: input port values</span>
<span class="sd">        :type inputs: list</span>
<span class="sd">        :param t: Simulation time, defaults to 0.0</span>
<span class="sd">        :type t: float, optional</span>

<span class="sd">        Step the block for a given set of input port</span>
<span class="sd">        values. Input port values are treated as lists.</span>

<span class="sd">        Mostly used for making concise unit tests.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check inputs and assign to attribute</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span><span class="p">,</span> <span class="s2">&quot;wrong number of inputs provided&quot;</span>

        <span class="c1"># step the block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.T_start">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.T_start">[docs]</a>
    <span class="k">def</span> <span class="nf">T_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simstate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">bdsim.run_sim</span> <span class="kn">import</span> <span class="n">BDSimState</span><span class="p">,</span> <span class="n">Options</span>

        <span class="k">if</span> <span class="n">simstate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">class</span> <span class="nc">RunTime</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">DEBUG</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">pass</span>

            <span class="k">class</span> <span class="nc">BlockDiagram</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">bd</span> <span class="o">=</span> <span class="n">BlockDiagram</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">RunTime</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">Options</span><span class="p">()</span>
            <span class="n">simstate</span> <span class="o">=</span> <span class="n">BDSimState</span><span class="p">()</span>
            <span class="n">simstate</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">options</span>
            <span class="n">simstate</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># step the block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">simstate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">simstate</span></div>


    <span class="k">def</span> <span class="nf">_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_output</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_step</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># def input(self, port):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Get input to block on specified port</span>

    <span class="c1">#     :param port: port number</span>
    <span class="c1">#     :type port: int</span>
    <span class="c1">#     :return: value applied to specified input port</span>
    <span class="c1">#     :rtype: any</span>

    <span class="c1">#     Return the value of the input applied to the input port numbered</span>
    <span class="c1">#     ``port``.  The type depends on the source port connected to this input.</span>

    <span class="c1">#     .. note:: When a block&#39;s ``output`` method is evaluated the resulting list is</span>
    <span class="c1">#         saved as an attribute of that block.  The ``input`` method traces back</span>
    <span class="c1">#         along the wire connected to the input port to obtain a reference to the</span>
    <span class="c1">#         output value held by the predecessor block.</span>

    <span class="c1">#     .. note:: For unit testing purposes, it the block is simply an instance</span>
    <span class="c1">#         of the class, then setting its attribute ``T_inputs`` to a list</span>
    <span class="c1">#         provides the input values to the block.</span>

    <span class="c1">#     :seealso: :meth:`inputs`</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         p = self.sources[port]  # get plug for source block output</span>
    <span class="c1">#         return p.block.output_values[p.port]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get block inputs as a list</span>

<span class="sd">        :return: list of block inputs</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        Returns a list of values corresponding to the input ports of the block.  The</span>
<span class="sd">        types of the elements are dictated by the blocks connected to the input ports.</span>

<span class="sd">        .. note:: When a block&#39;s ``output`` method is evaluated the resulting list is</span>
<span class="sd">            saved as an attribute of that block.  The ``inputs`` method uses the</span>
<span class="sd">            ``sources`` attribute which has references to the output values held by</span>
<span class="sd">            the predecessor block.</span>

<span class="sd">        :seealso: :meth:`input`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nin</span><span class="p">):</span>
            <span class="n">plug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="n">port</span><span class="p">]</span>  <span class="c1"># get plug for source block output</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plug</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">output_values</span><span class="p">[</span><span class="n">plug</span><span class="o">.</span><span class="n">port</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">values</span>

<div class="viewcode-block" id="Block.__getitem__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a block slice reference to a plug.</span>

<span class="sd">        :param port: Port number</span>
<span class="sd">        :type port: int</span>
<span class="sd">        :return: A port plug</span>
<span class="sd">        :rtype: Plug</span>

<span class="sd">        Invoked whenever a block is referenced as a slice, for example::</span>

<span class="sd">            c = bd.CONSTANT(1)</span>

<span class="sd">            bd.connect(x, c[0])</span>
<span class="sd">            bd.connect(c[0], x)</span>

<span class="sd">        In both cases ``c[0]`` is converted to a ``Plug`` by this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># block[i] is a plug object</span>
        <span class="c1"># print(&#39;getitem called&#39;, self, port)</span>
        <span class="k">return</span> <span class="n">Plug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.__setitem__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a LHS block slice reference to a wire.</span>

<span class="sd">        :param port: Port number</span>
<span class="sd">        :type port: int</span>
<span class="sd">        :param src: the RHS</span>
<span class="sd">        :type src: Block or Plug</span>

<span class="sd">        Used to create a wired connection by assignment, for example::</span>

<span class="sd">            X[0] = Y</span>

<span class="sd">        where ``X`` and ``Y`` are blocks. This method is implicitly invoked and</span>
<span class="sd">        creates a wire from ``Y`` to input port 0 of ``X``.</span>

<span class="sd">        .. note:: The square brackets on the left-hand-side is critical, and</span>
<span class="sd">            ``X = Y`` will simply overwrite the reference to ``X``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># b[port] = src</span>
        <span class="c1"># src --&gt; b[port]</span>
        <span class="c1"># print(&#39;connecting&#39;, src, self, port)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">port</span><span class="p">])</span></div>


<div class="viewcode-block" id="Block.__setattr__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__setattr__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a LHS block name reference to a wire.</span>

<span class="sd">        :param name: Port name</span>
<span class="sd">        :type port: str</span>
<span class="sd">        :param value: the RHS</span>
<span class="sd">        :type value: Block or Plug</span>

<span class="sd">        Used to create a wired connection by assignment, for example::</span>

<span class="sd">            c = bd.CONSTANT(1, inames=[&#39;u&#39;])</span>

<span class="sd">            c.u = x</span>

<span class="sd">        Ths method is invoked to create a wire from ``x`` to port &#39;u&#39; of</span>
<span class="sd">        the constant block ``c``.</span>

<span class="sd">        Notes:</span>

<span class="sd">            - this overloaded method handles all instances of ``setattr`` and</span>
<span class="sd">              implements normal functionality as well, only creating a wire</span>
<span class="sd">              if ``name`` is a known port name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># b[port] = src</span>
        <span class="c1"># src --&gt; b[port]</span>
        <span class="c1"># gets called for regular attribute settings, as well as for wiring</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">portnames</span><span class="p">:</span>
            <span class="c1"># we&#39;re doing wiring</span>
            <span class="c1"># print(&#39;in __setattr___&#39;, self, name, value)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># regular case, add attribute to the instance&#39;s dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Block.__rshift__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__rshift__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operator for implicit wiring.</span>

<span class="sd">        :param left: A block to be wired from</span>
<span class="sd">        :type left: Block</span>
<span class="sd">        :param right: A block or plugto be wired to</span>
<span class="sd">        :type right: Block or Plug</span>
<span class="sd">        :return: ``right``</span>
<span class="sd">        :rtype: Block or Plug</span>

<span class="sd">        Implements implicit wiring, for example::</span>

<span class="sd">            a = bd.CONSTANT(1) &gt;&gt; bd.GAIN(2)</span>

<span class="sd">        will connect the output of the CONSTANT block to the input of the</span>
<span class="sd">        GAIN block.  The result will be GAIN block, whose output in this case</span>
<span class="sd">        will be assigned to ``a``.</span>

<span class="sd">        Note that::</span>

<span class="sd">           a = bd.CONSTANT(1) &gt;&gt; func[1]</span>

<span class="sd">        will connect port 0 of CONSTANT to port 1 of ``func``, and port 1 of ``func``</span>
<span class="sd">        will be assigned to ``a``.  To specify a different outport port on ``func``</span>
<span class="sd">        we need to use parentheses::</span>

<span class="sd">            a = (bd.CONSTANT(1) &gt;&gt; func[1])[0]</span>

<span class="sd">        which will connect port 0 of CONSTANT ` to port 1 of ``func``, and port 0 of ``func``</span>
<span class="sd">        will be assigned to ``a``.</span>

<span class="sd">        :seealso: Plug.__rshift__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># called for the cases:</span>
        <span class="c1"># block * block</span>
        <span class="c1"># block * plug</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">bd</span>
        <span class="c1"># assert isinstance(right, Block), &#39;arguments to * must be blocks not ports (for now)&#39;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>  <span class="c1"># add a wire</span>
        <span class="c1"># print(&#39;block * &#39; + str(w))</span>
        <span class="k">return</span> <span class="n">right</span></div>


        <span class="c1"># make connection, return a plug</span>

    <span class="k">def</span> <span class="nf">_autoconstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_const.</span><span class="si">{:d}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_const</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_const.</span><span class="si">{:d}</span><span class="s2">&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_const</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_const</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">CONSTANT</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_autogain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_gain.</span><span class="si">{:d}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_gain</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_gain.</span><span class="si">{:d}</span><span class="s2">&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_gain</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_gain</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">GAIN</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_autopow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_pow.</span><span class="si">{:d}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_pow</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_pow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">POW</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Block.__add__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__add__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded + operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be added</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be added</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the + operator</span>
<span class="sd">        when the right operand is a ``Block``</span>
<span class="sd">        and the left operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X + Y</span>
<span class="sd">            result = X + Y[j]</span>
<span class="sd">            result = X + C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Creates a ``SUM(&quot;++&quot;) block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note::</span>
<span class="sd">            * The inputs to the summing junction are reversed: right then left operand.</span>
<span class="sd">            * The ``mode`` is None, regular addition</span>

<span class="sd">        :seealso: :meth:`Block.__radd__` :meth:`Plug.__add__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># value + value, create a SUM block</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_sum.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># block + constant, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoconstant</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;++&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.__radd__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__radd__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded + operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be added</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be added</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the + operator</span>
<span class="sd">        when the right operand is a ``Block``</span>
<span class="sd">        and the left operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X + Y[j]</span>
<span class="sd">            result = X[i] + Y[j]</span>
<span class="sd">            result = C + Y[j]</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Creates a ``SUM(&quot;++&quot;) block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note::</span>
<span class="sd">            * The inputs to the summing junction are reversed: right then left operand.</span>
<span class="sd">            * The ``mode`` is None, regular addition</span>

<span class="sd">        :seealso: :meth:`Block.__add__` :meth:`Plug.__radd__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># value + value, create a SUM block</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_sum.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant + block, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoconstant</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;++&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.__sub__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__sub__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded - operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be added (minuend)</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be subtracted (subtrahend)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the - operator when the left operand is a ``Block``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X - Y</span>
<span class="sd">            result = X - Y[j]</span>
<span class="sd">            result = X - C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Creates a ``SUM(&quot;+-&quot;)`` block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        :seealso: :meth:`Block.__rsub__` :meth:`Plug.__sub__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># value - value, create a SUM block</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_sum.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># block - constant, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoconstant</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.__rsub__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__rsub__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded - operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be added (minuend)</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be subtracted (subtrahend)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: SUM block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the - operator when the left operand is a ``Block``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X - Y</span>
<span class="sd">            result = X[i] - Y</span>
<span class="sd">            result = C - Y</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Creates a ``SUM(&quot;+-&quot;)`` block named ``_sum.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new ``CONSTANT(C)`` block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note::</span>
<span class="sd">            * The inputs to the summing junction are reversed: right then left operand.</span>
<span class="sd">            * The ``mode`` is None, regular addition</span>

<span class="sd">        :seealso: :meth:`Block.__sub__` :meth:`Plug.__rsub__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># value - value, create a SUM block</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_sum.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_sum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant - block, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoconstant</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">SUM</span><span class="p">(</span><span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.__neg__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__neg__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded unary minus operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be negated</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :return: GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the - operator for unary minus when the operand is a ``Block``::</span>

<span class="sd">            result = -X</span>

<span class="sd">        where ``X`` is a block.</span>

<span class="sd">        Creates a ``GAIN(-1)`` block named ``_gain.N`` whose input is the</span>
<span class="sd">        operand.</span>

<span class="sd">        :seealso: :meth:`Plug.__neg__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autogain</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span></div>


<div class="viewcode-block" id="Block.__pow__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__pow__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded unary power operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be negated</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :return: POW block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the ** operator for unary power when the operand is a ``Block``::</span>

<span class="sd">            result = X**3</span>

<span class="sd">        where ``X`` is a block.</span>

<span class="sd">        Creates a ``POW(3)`` block named ``_pow.N`` whose input is the</span>
<span class="sd">        operand.</span>

<span class="sd">        :seealso: :meth:`Plug.__pow__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autopow</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span></div>


<div class="viewcode-block" id="Block.__mul__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__mul__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded * operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be multiplied</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be multiplied</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD or GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the * operator when the left operand is a ``Block``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X * Y</span>
<span class="sd">            result = X * Y[j]</span>
<span class="sd">            result = X * C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``PROD(&quot;**&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.</span>

<span class="sd">        For the third case, create a ``GAIN(C)`` block named ``_gain.N``.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Block.__rmul__` :meth:`Plug.__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># block * constant, create a GAIN block</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autogain</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">premul</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># value * value, create a PROD block</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_prod.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">PROD</span><span class="p">(</span><span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.__rmul__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__rmul__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded * operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be multiplied</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be multiplied</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD or GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the * operator when the right operand is a ``Block``</span>
<span class="sd">        and the left operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X * Y</span>
<span class="sd">            result = X[i] * Y</span>
<span class="sd">            result = C * Y</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        For the first two cases, a ``PROD(&quot;**&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.</span>

<span class="sd">        For the third case, create a ``GAIN(C)`` block named ``_gain.N``.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Block.__mul__` :meth:`Plug.__rmul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant * block, create a GAIN block</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autogain</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">premul</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span></div>


<div class="viewcode-block" id="Block.__truediv__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__truediv__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded / operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be multiplied (dividend)</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be divided (divisor)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD or GAIN block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the / operator when the left operand is a ``Block``</span>
<span class="sd">        and the right operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X / Y</span>
<span class="sd">            result = X / Y[j]</span>
<span class="sd">            result = X / C</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        Create a ``PROD(&quot;**&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.</span>

<span class="sd">        For the third case, create a ``GAIN(1/C)`` block named ``_gain.N``.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Block.__rtruediv__` :meth:`Plug.__truediv__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># value / value, create a PROD block</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_prod.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># block / constant, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoconstant</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">PROD</span><span class="p">(</span><span class="s2">&quot;*/&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.__rtruediv__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__rtruediv__">[docs]</a>
    <span class="nd">@oodebug</span>
    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overloaded / operator for implicit block creation.</span>

<span class="sd">        :param self: A signal (block) to be multiplied (dividend)</span>
<span class="sd">        :type self: Block</span>
<span class="sd">        :param other: A signal (block or plug) to be divided (divisor)</span>
<span class="sd">        :type other: Block or Plug</span>
<span class="sd">        :return: PROD block</span>
<span class="sd">        :rtype: Block subclass</span>

<span class="sd">        This method is implicitly invoked by the / operator when the right operand is a ``Block``</span>
<span class="sd">        and the left operand is a ``Plug``, ``Block`` or constant::</span>

<span class="sd">            result = X / Y</span>
<span class="sd">            result = X[i] / Y</span>
<span class="sd">            result = C / Y</span>

<span class="sd">        where ``X`` and ``Y`` are blocks and ``C`` is a Python or NumPy constant.</span>

<span class="sd">        For the first two cases, a ``PROD(&quot;*/&quot;)`` block named ``_prod.N`` whose inputs are the</span>
<span class="sd">        left and right operands.  For the third case, a new CONSTANT block</span>
<span class="sd">        named ``_const.N`` is also created.</span>

<span class="sd">        .. note:: Signals are assumed to be scalars, but if ``C`` is a NumPy</span>
<span class="sd">            array then the option ``matrix`` is set to True.</span>

<span class="sd">        :seealso: :meth:`Block.__truediv__` :meth:`Plug.__rtruediv__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># value / value, create a PROD block</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_prod.</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">n_auto_prod</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># constant / block, create a CONSTANT block</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autoconstant</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bd</span><span class="o">.</span><span class="n">PROD</span><span class="p">(</span><span class="s2">&quot;*/&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


    <span class="c1"># TODO arithmetic with a constant, add a gain block or a constant block</span>

<div class="viewcode-block" id="Block.__str__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockclass</span> <span class="o">+</span> <span class="s2">&quot;.??&quot;</span></div>


<div class="viewcode-block" id="Block.__repr__">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.__repr__">[docs]</a>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_fixname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latex_remove</span><span class="p">)</span>

<div class="viewcode-block" id="Block.inport_names">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.inport_names">[docs]</a>
    <span class="k">def</span> <span class="nf">inport_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the names of block input ports.</span>

<span class="sd">        :param names: List of port names</span>
<span class="sd">        :type names: list of str</span>

<span class="sd">        Invoked by the ``inames`` argument to the Block constructor.</span>

<span class="sd">        The names can include LaTeX math markup.  The LaTeX version is used</span>
<span class="sd">        where appropriate, but the port names are a de-LaTeXd version of the</span>
<span class="sd">        given string with backslash, caret, braces and dollar signs</span>
<span class="sd">        removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inport_names</span> <span class="o">=</span> <span class="n">names</span>

        <span class="k">for</span> <span class="n">port</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixname</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">port</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">portnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.outport_names">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.outport_names">[docs]</a>
    <span class="k">def</span> <span class="nf">outport_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the names of block output ports.</span>

<span class="sd">        :param names: List of port names</span>
<span class="sd">        :type names: list of str</span>

<span class="sd">        Invoked by the ``onames`` argument to the Block constructor.</span>

<span class="sd">        The names can include LaTeX math markup.  The LaTeX version is used</span>
<span class="sd">        where appropriate, but the port names are a de-LaTeXd version of the</span>
<span class="sd">        given string with backslash, caret, braces and dollar signs</span>
<span class="sd">        removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outport_names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="k">for</span> <span class="n">port</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixname</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">port</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">portnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.state_names">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.state_names">[docs]</a>
    <span class="k">def</span> <span class="nf">state_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_names</span> <span class="o">=</span> <span class="n">names</span></div>


<div class="viewcode-block" id="Block.sourcename">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.sourcename">[docs]</a>
    <span class="k">def</span> <span class="nf">sourcename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the name of output port driving this input port.</span>

<span class="sd">        :param port: Input port</span>
<span class="sd">        :type port: int</span>
<span class="sd">        :return: Port name</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Return the name of the output port that drives the specified input</span>
<span class="sd">        port. The name can be:</span>

<span class="sd">            - a LaTeX string if provided</span>
<span class="sd">            - block name with port number given in square brackets.  The block</span>
<span class="sd">              name will the one optionally assigned by the user using the ``name``</span>
<span class="sd">              keyword, otherwise a systematic default name.</span>

<span class="sd">        :seealso: outport_names</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_wires</span><span class="p">[</span><span class="n">port</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">name</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">block</span>
        <span class="n">srcp</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">port</span>
        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">_outport_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">src</span><span class="o">.</span><span class="n">_outport_names</span><span class="p">[</span><span class="n">srcp</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="p">)</span></div>


    <span class="c1"># @property</span>
    <span class="c1"># def fullname(self):</span>
    <span class="c1">#     return self.blockclass + &quot;.&quot; + str(self)</span>

<div class="viewcode-block" id="Block.reset">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Block.add_output_wire">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.add_output_wire">[docs]</a>
    <span class="k">def</span> <span class="nf">add_output_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">port</span>
        <span class="k">assert</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_wires</span><span class="p">),</span> <span class="s2">&quot;port number too big&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_wires</span><span class="p">[</span><span class="n">port</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.add_input_wire">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.add_input_wire">[docs]</a>
    <span class="k">def</span> <span class="nf">add_input_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">port</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_wires</span><span class="p">[</span><span class="n">port</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;attempting to connect second wire to an input&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_wires</span><span class="p">[</span><span class="n">port</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="n">port</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">start</span></div>


    <span class="c1"># def setinput(self, port, value):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Receive input from a wire</span>

    <span class="c1">#     :param self: Block to be updated</span>
    <span class="c1">#     :type wire: Block</span>
    <span class="c1">#     :param port: Input port to be updated</span>
    <span class="c1">#     :type port: int</span>
    <span class="c1">#     :param value: Input value</span>
    <span class="c1">#     :type val: any</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # stash it away</span>
    <span class="c1">#     self.inputs[port] = value</span>

    <span class="c1"># def setinputs(self, *pos):</span>
    <span class="c1">#     assert len(pos) == self.nin, &#39;mismatch in number of inputs&#39;</span>
    <span class="c1">#     self.reset()</span>
    <span class="c1">#     for i, val in enumerate(pos):</span>
    <span class="c1">#         self.inputs[i] = val</span>

<div class="viewcode-block" id="Block.start">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.start">[docs]</a>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simstate</span><span class="p">):</span>  <span class="c1"># begin a simulation</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="Block.check">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.check">[docs]</a>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># check validity of block parameters at start</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nin&quot;</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;block </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has no nin specified&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nout&quot;</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;block </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has no nout specified&quot;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nin</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nout</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;block </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> no inputs or outputs specified&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;initd&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initd</span>
        <span class="p">),</span> <span class="s2">&quot;Block superclass not initalized. was super().__init__ called?&quot;</span></div>


<div class="viewcode-block" id="Block.done">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.done">[docs]</a>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># end of simulation</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="Block.savefig">
<a class="viewcode-back" href="../../internals.html#bdsim.Block.savefig">[docs]</a>
    <span class="k">def</span> <span class="nf">savefig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="SinkBlock">
<a class="viewcode-back" href="../../internals.html#bdsim.SinkBlock">[docs]</a>
<span class="k">class</span> <span class="nc">SinkBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A SinkBlock is a subclass of Block that represents a block that has inputs</span>
<span class="sd">    but no outputs. Typically used to save data to a variable, file or</span>
<span class="sd">    graphics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">blockclass</span> <span class="o">=</span> <span class="s2">&quot;sink&quot;</span>

<div class="viewcode-block" id="SinkBlock.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.SinkBlock.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">blockargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a sink block.</span>

<span class="sd">        :param blockargs: |BlockOptions|</span>
<span class="sd">        :type blockargs: dict</span>
<span class="sd">        :return: sink block base class</span>
<span class="sd">        :rtype: SinkBlock</span>

<span class="sd">        This is the parent class of all sink blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Sink constructor&#39;)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">blockargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nout</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="SinkBlock.step">
<a class="viewcode-back" href="../../internals.html#bdsim.SinkBlock.step">[docs]</a>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">inports</span><span class="p">):</span>  <span class="c1"># valid</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="SourceBlock">
<a class="viewcode-back" href="../../internals.html#bdsim.SourceBlock">[docs]</a>
<span class="k">class</span> <span class="nc">SourceBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A SourceBlock is a subclass of Block that represents a block that has outputs</span>
<span class="sd">    but no inputs.  Its output is a function of parameters and time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">blockclass</span> <span class="o">=</span> <span class="s2">&quot;source&quot;</span>

<div class="viewcode-block" id="SourceBlock.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.SourceBlock.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">blockargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a source block.</span>

<span class="sd">        :param blockargs: |BlockOptions|</span>
<span class="sd">        :type blockargs: dict</span>
<span class="sd">        :return: source block base class</span>
<span class="sd">        :rtype: SourceBlock</span>

<span class="sd">        This is the parent class of all source blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Source constructor&#39;)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">blockargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>



<div class="viewcode-block" id="TransferBlock">
<a class="viewcode-back" href="../../internals.html#bdsim.TransferBlock">[docs]</a>
<span class="k">class</span> <span class="nc">TransferBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A TransferBlock is a subclass of Block that represents a block with inputs</span>
<span class="sd">    outputs and states. Typically used to describe a continuous time dynamic</span>
<span class="sd">    system, either linear or nonlinear.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">blockclass</span> <span class="o">=</span> <span class="s2">&quot;transfer&quot;</span>

<div class="viewcode-block" id="TransferBlock.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.TransferBlock.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nstates</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">blockargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a transfer function block.</span>

<span class="sd">        :param blockargs: |BlockOptions|</span>
<span class="sd">        :type blockargs: dict</span>
<span class="sd">        :return: transfer function block base class</span>
<span class="sd">        :rtype: TransferBlock</span>

<span class="sd">        This is the parent class of all transfer function blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Transfer constructor&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="n">nstates</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">blockargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TransferBlock.reset">
<a class="viewcode-back" href="../../internals.html#bdsim.TransferBlock.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span></div>

        <span class="c1"># return self._x</span>

<div class="viewcode-block" id="TransferBlock.setstate">
<a class="viewcode-back" href="../../internals.html#bdsim.TransferBlock.setstate">[docs]</a>
    <span class="k">def</span> <span class="nf">setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">]</span>  <span class="c1"># take as much state vector as we need</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="p">:]</span>  <span class="c1"># return the rest</span></div>


<div class="viewcode-block" id="TransferBlock.getstate0">
<a class="viewcode-back" href="../../internals.html#bdsim.TransferBlock.getstate0">[docs]</a>
    <span class="k">def</span> <span class="nf">getstate0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span></div>


<div class="viewcode-block" id="TransferBlock.check">
<a class="viewcode-back" href="../../internals.html#bdsim.TransferBlock.check">[docs]</a>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x0</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span><span class="p">,</span> <span class="s2">&quot;incorrect length for initial state&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;no inputs or outputs specified&quot;</span></div>
</div>



<div class="viewcode-block" id="FunctionBlock">
<a class="viewcode-back" href="../../internals.html#bdsim.FunctionBlock">[docs]</a>
<span class="k">class</span> <span class="nc">FunctionBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A FunctionBlock is a subclass of Block that represents a block that has inputs</span>
<span class="sd">    and outputs but no state variables.  Typically used to describe operations</span>
<span class="sd">    such as gain, summation or various mappings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">blockclass</span> <span class="o">=</span> <span class="s2">&quot;function&quot;</span>

<div class="viewcode-block" id="FunctionBlock.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.FunctionBlock.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">blockargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a function block.</span>

<span class="sd">        :param blockargs: |BlockOptions|</span>
<span class="sd">        :type blockargs: dict</span>
<span class="sd">        :return: function block base class</span>
<span class="sd">        :rtype: FunctionBlock</span>

<span class="sd">        This is the parent class of all function blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Function constructor&#39;)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">blockargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>



<div class="viewcode-block" id="SubsystemBlock">
<a class="viewcode-back" href="../../internals.html#bdsim.SubsystemBlock">[docs]</a>
<span class="k">class</span> <span class="nc">SubsystemBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A SubSystem  s a subclass of Block that represents a block that has inputs</span>
<span class="sd">    and outputs but no state variables.  Typically used to describe operations</span>
<span class="sd">    such as gain, summation or various mappings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">blockclass</span> <span class="o">=</span> <span class="s2">&quot;subsystem&quot;</span>

<div class="viewcode-block" id="SubsystemBlock.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.SubsystemBlock.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">blockargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a subsystem block.</span>

<span class="sd">        :param blockargs: |BlockOptions|</span>
<span class="sd">        :type blockargs: dict</span>
<span class="sd">        :return: subsystem block base class</span>
<span class="sd">        :rtype: SubsystemBlock</span>

<span class="sd">        This is the parent class of all subsystem blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Subsystem constructor&#39;)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">blockargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>



<div class="viewcode-block" id="ClockedBlock">
<a class="viewcode-back" href="../../internals.html#bdsim.ClockedBlock">[docs]</a>
<span class="k">class</span> <span class="nc">ClockedBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ClockedBlock is a subclass of Block that represents a block with inputs</span>
<span class="sd">    outputs and discrete states. Typically used to describe a discrete time dynamic</span>
<span class="sd">    system, either linear or nonlinear.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">blockclass</span> <span class="o">=</span> <span class="s2">&quot;clocked&quot;</span>

<div class="viewcode-block" id="ClockedBlock.__init__">
<a class="viewcode-back" href="../../internals.html#bdsim.ClockedBlock.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">blockargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a clocked block.</span>

<span class="sd">        :param blockargs: |BlockOptions|</span>
<span class="sd">        :type blockargs: dict</span>
<span class="sd">        :return: clocked block base class</span>
<span class="sd">        :rtype: ClockedBlock</span>

<span class="sd">        This is the parent class of all clocked blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Clocked constructor&#39;)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">blockargs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">clock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;clocked block must have a clock&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clocked</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">clock</span>
        <span class="n">clock</span><span class="o">.</span><span class="n">add_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="ClockedBlock.reset">
<a class="viewcode-back" href="../../internals.html#bdsim.ClockedBlock.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>

        <span class="c1"># self._x = self._x0</span>
        <span class="c1"># return self._x</span>

<div class="viewcode-block" id="ClockedBlock.setstate">
<a class="viewcode-back" href="../../internals.html#bdsim.ClockedBlock.setstate">[docs]</a>
    <span class="k">def</span> <span class="nf">setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndstates</span><span class="p">]</span>  <span class="c1"># take as much state vector as we need</span>
        <span class="c1"># print(&#39;** set block state to &#39;, self._x)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ndstates</span> <span class="p">:]</span>  <span class="c1"># return the rest</span></div>


<div class="viewcode-block" id="ClockedBlock.getstate0">
<a class="viewcode-back" href="../../internals.html#bdsim.ClockedBlock.getstate0">[docs]</a>
    <span class="k">def</span> <span class="nf">getstate0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span></div>


<div class="viewcode-block" id="ClockedBlock.check">
<a class="viewcode-back" href="../../internals.html#bdsim.ClockedBlock.check">[docs]</a>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x0</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndstates</span><span class="p">,</span> <span class="s2">&quot;incorrect length for initial state&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">nin</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;no inputs or outputs specified&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span></div>
</div>



<span class="k">class</span> <span class="nc">EventSource</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="c1"># c = Clock(5)</span>
<span class="c1"># c1 = Clock(5, 2)</span>

<span class="c1"># print(c, c1)</span>
<span class="c1"># print(c.next(0), c1.next(0))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># opt = OptionsBase(dict(foo=1, bar=&#39;hello&#39;))</span>
    <span class="c1"># print(opt.foo)</span>
    <span class="c1"># print(opt.bar)</span>
    <span class="c1"># opt.set(foo=3)</span>
    <span class="c1"># print(opt.foo)</span>

    <span class="c1"># from bdsim.blocks.functions import Sum</span>
    <span class="c1"># print(Sum.parameters())</span>

    <span class="kn">import</span> <span class="nn">bdsim</span>

    <span class="n">sim</span> <span class="o">=</span> <span class="n">bdsim</span><span class="o">.</span><span class="n">BDSim</span><span class="p">()</span>  <span class="c1"># create simulator</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">moduledicts</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-, Peter Corke..
      <span class="lastupdated">Last updated on 06-Aug-2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>